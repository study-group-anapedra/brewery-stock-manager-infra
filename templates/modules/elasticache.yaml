AWSTemplateFormatVersion: "2010-09-09"
Description: ElastiCache Redis for Application Tier - Corrigido

Parameters:
  Environment: { Type: String, AllowedValues: [dev, prod] }
  ProjectName: { Type: String }
  VpcId: { Type: AWS::EC2::VPC::Id }
  PrivateAppSubnets: { Type: "List<AWS::EC2::Subnet::Id>" }
  AppSecurityGroupId: { Type: AWS::EC2::SecurityGroup::Id }

Resources:

  # 1. Segurança: Porta 6379 aberta apenas para o Backend Java
  RedisSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Allow Redis access from App Tier
      VpcId: { Ref: VpcId }
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 6379
          ToPort: 6379
          SourceSecurityGroupId: { Ref: AppSecurityGroupId }
      Tags:
        - Key: Name
          Value: { Fn::Sub: "${ProjectName}-${Environment}-redis-sg" }

  # 2. Grupo de Subnets: Garante que o Redis rode na camada App (privada)
  RedisSubnetGroup:
    Type: AWS::ElastiCache::SubnetGroup
    Properties:
      Description: Subnet group for Redis
      SubnetIds: { Ref: PrivateAppSubnets }

  # 3. Cluster Redis: Versão t3.micro para controle de custos em Dev
  RedisCluster:
    Type: AWS::ElastiCache::CacheCluster
    Properties:
      Engine: redis
      CacheNodeType: cache.t3.micro
      NumCacheNodes: 1
      VpcSecurityGroupIds: [{ Ref: RedisSecurityGroup }]
      CacheSubnetGroupName: { Ref: RedisSubnetGroup }
      Tags:
        - Key: Name
          Value: { Fn::Sub: "${ProjectName}-${Environment}-redis" }

Outputs:
  RedisEndpoint:
    Value: { Fn::GetAtt: [ RedisCluster, RedisEndpoint.Address ] }
  RedisPort:
    Value: { Fn::GetAtt: [ RedisCluster, RedisEndpoint.Port ] }